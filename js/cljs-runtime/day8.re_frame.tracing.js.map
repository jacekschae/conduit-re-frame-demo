{"version":3,"file":"day8.re_frame.tracing.js","sources":["day8/re_frame/tracing.cljc"],"mappings":";;;;;AAQS,AAACA;AAED,AAAA,AAAA;AAAA;AAAA,AAAAC,YAAA,6CAAA;AAGT;;;gDAAA,hDAAeC;AAAf,AAOEC;;AAEF,AAAKC,iDAAoBC;AACzB,AAAKC,mDAAsBC;AAiB3B,gCAAA,hCAAMC,wEAASC;AAAf,AACE,GAAI,6CAAA,7CAACM,mGAAQ,gJAAA,hJAACC,4CAAI,AAAA,oFAAOP;AAAzB,OAAAC,iDAAA,AAAAC,cAAA,AAAAC,+CAAA,KAAAC,eAAA,KACK,iBAAAI,mBAAI,AAAA,mFAAO,AAAA,mFAAOR;AAAlB,AAAA,oBAAAQ;AAAAA;;AAAA;;KADL,KAAA,IAAA,OAEO,AAACC,4CAAI,WAAKC;AAAL,AAAA,OAAAT,iDAAA,AAAAC,cAAA,AAAAC,+CAAA,KAAAC,eAAA,KAAA,mGAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,UAAA,KAAA,IAAA,dAAmBM;GAAO,gJAAA,hJAACH,4CAAI,AAAA,oFAAOP;;AAFlD,OAAAC,iDAAA,AAAAC,cAAA,AAAAG,sDAAA,KAAAD,eAAA,KAIK,iBAAAI,mBAAI,AAAA,mFAAO,AAAA,mFAAOR;AAAlB,AAAA,oBAAAQ;AAAAA;;AAAA;;KAJL,KAAA,IAAA,OAAA,KAAAJ,eAAA,oPAAA,KAAA,IAAA,xPAKM,AAAA,yFAAU,gJAAA,hJAACG,4CAAI,AAAA,oFAAOP,wFACrB,AAACS,4CAAI,WAAKC;AAAL,AAAA,OAAAT,iDAAA,AAAAC,cAAA,AAAAC,+CAAA,KAAAC,eAAA,KAAA,mGAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,UAAA,KAAA,IAAA,dAAmBM;GAAO,AAAA,oFAAO,gJAAA,hJAACH,4CAAI,AAAA,oFAAOP","names":["cljs.core/enable-console-print!","goog/define","day8.re-frame.tracing/is-trace-enabled?","day8.re-frame.tracing/trace-enabled?","day8.re-frame.tracing/reset-indent-level!","debux.common.util/reset-indent-level!","day8.re-frame.tracing/set-print-seq-length!","debux.common.util/set-print-seq-length!","day8.re-frame.tracing/fn-body","args+body","cljs.core.sequence.cljs$core$IFn$_invoke$arity$1","cljs.core/seq","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","cljs.core/List","cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","or__3922__auto__","cljs.core.map.cljs$core$IFn$_invoke$arity$2","body"],"sourcesContent":["(ns day8.re-frame.tracing\n  #?(:cljs (:require-macros\n             [debux.dbgn :as dbgn]\n             [debux.cs.macro-types :as mt]))\n  (:require [debux.common.util :as ut]\n            [debux.common.macro-specs :as ms]\n            [clojure.spec.alpha :as s]))\n\n#?(:cljs (enable-console-print!))\n\n#?(:cljs (goog-define trace-enabled? false)\n   :clj  (def ^boolean trace-enabled? false))\n\n(defn ^boolean is-trace-enabled?\n  \"See https://groups.google.com/d/msg/clojurescript/jk43kmYiMhA/IHglVr_TPdgJ for more details\"\n  ;; We can remove this extra step of type hinting indirection once our minimum CLJS version includes\n  ;; https://dev.clojure.org/jira/browse/CLJS-1439\n  ;; r1.10.63 is the first version with this:\n  ;; https://github.com/clojure/clojurescript/commit/9ec796d791b1b2bd613af2f62cdecfd25caa6482\n  []\n  trace-enabled?)\n\n(def reset-indent-level! ut/reset-indent-level!)\n(def set-print-seq-length! ut/set-print-seq-length!)\n\n\n;;; debugging APIs\n(defmacro dbgn [form & opts]\n  (let [opts' (ut/parse-opts opts)]\n    `(debux.dbgn/dbgn ~form ~opts')))\n\n;;; macro registering APIs\n(defmacro register-macros! [macro-type symbols]\n  `(debux.cs.macro-types/register-macros! ~macro-type ~symbols))\n\n(defmacro show-macros\n  ([] `(debux.cs.macro-types/show-macros))\n  ([macro-type] `(debux.cs.macro-types/show-macros ~macro-type)))\n\n\n(defn fn-body [args+body]\n  (if (= :body (nth (:body args+body) 0))\n    `(~(or (:args (:args args+body)) [])\n       ~@(map (fn [body] `(dbgn ~body)) (nth (:body args+body) 1)))\n    ;; prepost+body\n    `(~(or (:args (:args args+body)) [])\n       ~(:prepost (nth (:body args+body) 1))\n       ~@(map (fn [body] `(dbgn ~body)) (:body (nth (:body args+body) 1))))))\n\n;; Components of a defn\n;; name\n;; docstring?\n;; meta?\n;; bs (1-n)\n;; body\n;; prepost?\n\n(defmacro defn-traced*\n  [& definition]\n  (let [conformed (s/conform ::ms/defn-args definition)\n        name      (:name conformed)\n        bs        (:bs conformed)\n        arity-1?  (= (nth bs 0) :arity-1)\n        args+body (nth bs 1)]\n    (if arity-1?\n      `(defn ~name ~@(fn-body args+body))\n      `(defn ~name ~@(map fn-body (:bodies args+body))))))\n\n(defmacro defn-traced\n  \"Traced defn\"\n  {:arglists '([name doc-string? attr-map? [params*] prepost-map? body]\n                [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?])}\n  [& definition]\n  `(if (is-trace-enabled?)\n     (defn-traced* ~@definition)\n     (defn ~@definition)))\n\n\n\n;; Components of a fn\n;; name?\n;; bs (1-n)\n;; body\n;; prepost?\n\n(defmacro fn-traced*\n  \"Traced form of fn. Prefer fn-traced to compile out under advanced optimizations.\"\n  [& definition]\n  (let [conformed (s/conform ::ms/fn-args definition)\n        name      (:name conformed)\n        bs        (:bs conformed)\n        arity-1?  (= (nth bs 0) :arity-1)\n        args+body (nth bs 1)]\n    (if arity-1?\n      ;; If name is nil, then the empty vector is removed by the unquote\n      `(fn ~@(when name [name])\n         ~@(fn-body args+body))\n      ;; arity-n\n      (let [bodies (:bodies args+body)]\n        `(fn ~@(when name [name])\n           ~@(map fn-body bodies))))))\n\n(defmacro fn-traced\n  \"Defines a traced fn\"\n  {:arglists '[(fn name? [params*] exprs*) (fn name? ([params*] exprs*) +)]}\n  [& definition]\n  `(if (is-trace-enabled?)\n     (fn-traced* ~@definition)\n     (fn ~@definition)))\n\n"]}