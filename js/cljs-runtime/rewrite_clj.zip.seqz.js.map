{"version":3,"file":"rewrite_clj.zip.seqz.js","sources":["rewrite_clj/zip/seqz.cljs"],"mappings":"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","names":["f","zloc","parent","rewrite-clj.zip.move/right","v","rewrite-clj.zip.move/up","js/Error","rewrite-clj.zip.seqz/get","temp__5455__auto__","v0","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","rewrite-clj.zip.base/tag","cljs.core/not","and__3911__auto__","loc","clojure.zip/node","vloc","k","rewrite-clj.zip.editz/replace","G__29037","n0","rewrite-clj.zip.insert/append-child","G__29055","cljs.core.take_while.cljs$core$IFn$_invoke$arity$2","cljs.core/identity","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","rewrite-clj.zip.seqz/map","rewrite-clj.zip.seqz/vector?","cljs.core/iterate","G__29054","rewrite-clj.zip.move/down","rewrite_clj.zip.findz.find_value.cljs$core$IFn$_invoke$arity$2","cljs.core/contains?","rewrite-clj.zip.seqz/map?","rewrite-clj.zip.seqz/seq?","cljs.core/integer?","or__3922__auto__","n","rewrite-clj.zip.seqz/set?","rewrite-clj.zip.seqz/list?","rewrite-clj.zip.seqz/map-seq","cljs.core/last","rewrite-clj.zip.seqz/map-vals","rewrite-clj.zip.seqz/assoc","rewrite-clj.zip.seqz/map-keys"],"sourcesContent":["(ns rewrite-clj.zip.seqz\n  (:refer-clojure :exclude [map get assoc seq? vector? list? map? set?])\n  (:require [rewrite-clj.zip.base :as base]\n            [rewrite-clj.zip.editz :as e]\n            [rewrite-clj.zip.findz :as f]\n            [rewrite-clj.zip.insert :as i]\n            [rewrite-clj.zip.move :as m]\n            [clojure.zip :as z]))\n\n;; ## Predicates\n\n(defn seq?\n  [zloc]\n  (contains?\n    #{:forms :list :vector :set :map}\n    (base/tag zloc)))\n\n(defn list?\n  [zloc]\n  (= (base/tag zloc) :list))\n\n(defn vector?\n  [zloc]\n  (= (base/tag zloc) :vector))\n\n(defn set?\n  [zloc]\n  (= (base/tag zloc) :set))\n\n(defn map?\n  [zloc]\n  (= (base/tag zloc) :map))\n\n;; ## Map Operations\n\n(defn- map-seq\n  [f zloc]\n  {:pre [(seq? zloc)]}\n  (if-let [n0 (m/down zloc)]\n    (some->> (f n0)\n             (iterate\n               (fn [loc]\n                 (if-let [n (m/right loc)]\n                   (f n))))\n             (take-while identity)\n             (last)\n             (m/up))\n    zloc))\n\n(defn map-vals\n  \"Apply function to all value nodes of the given map node.\"\n  [f zloc]\n  {:pre [(map? zloc)]}\n  (loop [loc (m/down zloc)\n         parent zloc]\n    (if-not (and loc (z/node loc))\n      parent\n      (if-let [v0 (m/right loc)]\n        (if-let [v (f v0)]\n          (recur (m/right v) (m/up v))\n          (recur (m/right v0) parent))\n        parent))))\n\n(defn map-keys\n  \"Apply function to all key nodes of the given map node.\"\n  [f zloc]\n  {:pre [(map? zloc)]}\n  (loop [loc (m/down zloc)\n         parent zloc]\n    (if-not (and loc (z/node loc))\n      parent\n      (if-let [v (f loc)]\n        (recur (m/right (m/right v)) (m/up v))\n        (recur (m/right (m/right loc)) parent)))))\n\n(defn map\n  \"Apply function to all value nodes in the given seq node. Iterates over\n   value nodes of maps but over each element of a seq.\"\n  [f zloc]\n  {:pre [(seq? zloc)]}\n  (if (map? zloc)\n    (map-vals f zloc)\n    (map-seq f zloc)))\n\n;; ## Get/Assoc\n\n(defn get\n  \"If a map is given, get element with the given key; if a seq is given, get nth element.\"\n  [zloc k]\n  {:pre [(or (map? zloc) (and (seq? zloc) (integer? k)))]}\n  (if (map? zloc)\n    (some-> zloc m/down (f/find-value k) m/right)\n    (nth\n      (some->> (m/down zloc)\n               (iterate m/right)\n               (take-while identity))\n      k)))\n\n(defn assoc\n  \"Set map/seq element to the given value.\"\n  [zloc k v]\n  (if-let [vloc (get zloc k)]\n    (-> vloc (e/replace v) m/up)\n    (if (map? zloc)\n      (-> zloc\n          (i/append-child k)\n          (i/append-child v))\n      (throw\n        (js/Error.\n          (str \"index out of bounds: \" k))))))\n"]}