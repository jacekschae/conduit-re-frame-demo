{"version":3,"file":"re_frame.core.js","sources":["re_frame/core.cljc"],"mappings":"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","names":["re-frame.core/debug","re-frame.std-interceptors/debug","re-frame.core/clear-cofx","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","re-frame.registrar/clear-handlers","re-frame.cofx/kind","var_args","G__40188","re-frame.core/reg-event-db","js/Error","re-frame.router/add-post-event-callback","re-frame.router/event-queue","id","f","args__4502__auto__","len__4499__auto__","i__4500__auto__","argseq__4503__auto__","cljs.core/IndexedSeq","re-frame.core/register-sub","seq40245","self__4487__auto__","cljs.core/seq","handler","args","re-frame.core/reg-fx","re-frame.fx/reg-fx","G__40191","re-frame.core/reg-event-fx","re-frame.core/clear-fx","re-frame.fx/kind","cljs.core/deref","handlers","re-frame.registrar/kind->id->handler","re-frame.registrar/register-handler","re-frame.subs/kind","query-id","handler-fn","re-frame.core/dispatch","re-frame.router/dispatch","re-frame.core/get-effect","re-frame.interceptor/get-effect","app-db","re-frame.db/app-db","re-frame.core/remove-post-event-callback","re-frame.core/->interceptor","re-frame.interceptor/->interceptor","re-frame.core/clear-subscription-cache!","re-frame.subs/clear-subscription-cache!","re-frame.core/reg-sub-raw","interceptors","re-frame.std-interceptors/ctx-handler->interceptor","re-frame.cofx/inject-db","re-frame.fx/do-fx","re-frame.events/register","current-subs","cljs.core/set","cljs.core/vals","re-frame.subs/query->reaction","re-frame.core/purge-event-queue","G__40246","G__40247","G__40248","G__40249","re-frame.core/console","cljs.core/first","re-frame.core/dispatch-sync","re-frame.router/dispatch-sync","re-frame.core/set-loggers!","re-frame.loggers/set-loggers!","re-frame.router/remove-post-event-callback","original-subs","subs-cache","re-frame.core/make-restore-fn","re_frame.core.add_post_event_callback.cljs$core$IFn$_invoke$arity$2","re-frame.core/assoc-coeffect","re-frame.interceptor/assoc-coeffect","re-frame.router/purge","re-frame.interop/dispose!","sub","re-frame.std-interceptors/fx-handler->interceptor","re-frame.core/path","re-frame.std-interceptors/path","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","re-frame.core/reg-sub","re-frame.subs/reg-sub","re_frame.core.reg_event_ctx.cljs$core$IFn$_invoke$arity$3","re-frame.core/inject-cofx","re-frame.cofx/inject-cofx","cljs.core/reset!","G__40194","re-frame.core/reg-event-ctx","re-frame.core/enqueue","re-frame.interceptor/enqueue","re-frame.core/register-handler","seq40230","re-frame.core/after","re-frame.std-interceptors/after","re-frame.core/get-coeffect","re-frame.interceptor/get-coeffect","G__40233","G__40234","G__40235","G__40236","re-frame.core/clear-sub","G__40227","re-frame.core/add-post-event-callback","re-frame.core/clear-event","re-frame.events/kind","re-frame.core/assoc-effect","re-frame.interceptor/assoc-effect","re-frame.std-interceptors/db-handler->interceptor","re-frame.core/subscribe","re-frame.subs/subscribe","re-frame.core/enrich","re-frame.std-interceptors/enrich","re-frame.loggers/console","re_frame.core.reg_event_db.cljs$core$IFn$_invoke$arity$3","re-frame.core/on-changes","re-frame.std-interceptors/on-changes","re_frame.core.reg_event_fx.cljs$core$IFn$_invoke$arity$3","re-frame.core/trim-v","re-frame.std-interceptors/trim-v","seq__40199","chunk__40200","count__40201","i__40202","temp__5457__auto__","cljs.core/chunked-seq?","c__4319__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","cljs.core/next","clojure.set.difference.cljs$core$IFn$_invoke$arity$2","re-frame.core/reg-cofx","re-frame.cofx/reg-cofx"],"sourcesContent":["(ns re-frame.core\n  (:require\n    [re-frame.events           :as events]\n    [re-frame.subs             :as subs]\n    [re-frame.interop          :as interop]\n    [re-frame.db               :as db]\n    [re-frame.fx               :as fx]\n    [re-frame.cofx             :as cofx]\n    [re-frame.router           :as router]\n    [re-frame.loggers          :as loggers]\n    [re-frame.registrar        :as registrar]\n    [re-frame.interceptor      :as interceptor]\n    [re-frame.std-interceptors :as std-interceptors :refer [db-handler->interceptor\n                                                             fx-handler->interceptor\n                                                             ctx-handler->interceptor]]\n    [clojure.set               :as set]))\n\n\n;; -- API ---------------------------------------------------------------------\n;;\n;; This namespace represents the re-frame API\n;;\n;; Below, you'll see we've used this technique:\n;;   (def  api-name-for-fn    deeper.namespace/where-the-defn-is)\n;;\n;; So, we promote a `defn` in a deeper namespace \"up\" to the API\n;; via a `def` in this namespace.\n;;\n;; Turns out, this approach makes it hard:\n;;   - to auto-generate API docs\n;;   - for IDEs to provide code completion on functions in the API\n;;\n;; Which is annoying. But there are pros and cons and we haven't\n;; yet revisited the decision.  To compensate, we've added more nudity\n;; to the docs.\n;;\n\n\n;; -- dispatch ----------------------------------------------------------------\n(def dispatch       router/dispatch)\n(def dispatch-sync  router/dispatch-sync)\n\n\n;; -- subscriptions -----------------------------------------------------------\n(def reg-sub        subs/reg-sub)\n(def subscribe      subs/subscribe)\n\n(def clear-sub (partial registrar/clear-handlers subs/kind))  ;; think unreg-sub\n(def clear-subscription-cache! subs/clear-subscription-cache!)\n\n(defn reg-sub-raw\n  \"This is a low level, advanced function.  You should probably be\n  using reg-sub instead.\n  Docs in https://github.com/Day8/re-frame/blob/master/docs/SubscriptionFlow.md\"\n  [query-id handler-fn]\n  (registrar/register-handler subs/kind query-id handler-fn))\n\n\n;; -- effects -----------------------------------------------------------------\n(def reg-fx      fx/reg-fx)\n(def clear-fx    (partial registrar/clear-handlers fx/kind))  ;; think unreg-fx\n\n;; -- coeffects ---------------------------------------------------------------\n(def reg-cofx    cofx/reg-cofx)\n(def inject-cofx cofx/inject-cofx)\n(def clear-cofx (partial registrar/clear-handlers cofx/kind)) ;; think unreg-cofx\n\n\n;; -- Events ------------------------------------------------------------------\n\n(defn reg-event-db\n  \"Register the given event `handler` (function) for the given `id`. Optionally, provide\n  an `interceptors` chain.\n  `id` is typically a namespaced keyword  (but can be anything)\n  `handler` is a function: (db event) -> db\n  `interceptors` is a collection of interceptors. Will be flattened and nils removed.\n  `handler` is wrapped in its own interceptor and added to the end of the interceptor\n   chain, so that, in the end, only a chain is registered.\n   Special effects and coeffects interceptors are added to the front of this\n   chain.\"\n  ([id handler]\n    (reg-event-db id nil handler))\n  ([id interceptors handler]\n   (events/register id [cofx/inject-db fx/do-fx interceptors (db-handler->interceptor handler)])))\n\n\n(defn reg-event-fx\n  \"Register the given event `handler` (function) for the given `id`. Optionally, provide\n  an `interceptors` chain.\n  `id` is typically a namespaced keyword  (but can be anything)\n  `handler` is a function: (coeffects-map event-vector) -> effects-map\n  `interceptors` is a collection of interceptors. Will be flattened and nils removed.\n  `handler` is wrapped in its own interceptor and added to the end of the interceptor\n   chain, so that, in the end, only a chain is registered.\n   Special effects and coeffects interceptors are added to the front of the\n   interceptor chain.  These interceptors inject the value of app-db into coeffects,\n   and, later, action effects.\"\n  ([id handler]\n   (reg-event-fx id nil handler))\n  ([id interceptors handler]\n   (events/register id [cofx/inject-db fx/do-fx interceptors (fx-handler->interceptor handler)])))\n\n\n(defn reg-event-ctx\n  \"Register the given event `handler` (function) for the given `id`. Optionally, provide\n  an `interceptors` chain.\n  `id` is typically a namespaced keyword  (but can be anything)\n  `handler` is a function: (context-map event-vector) -> context-map\n\n  This form of registration is almost never used. \"\n  ([id handler]\n   (reg-event-ctx id nil handler))\n  ([id interceptors handler]\n   (events/register id [cofx/inject-db fx/do-fx interceptors (ctx-handler->interceptor handler)])))\n\n(def clear-event (partial registrar/clear-handlers events/kind)) ;; think unreg-event-*\n\n;; -- interceptors ------------------------------------------------------------\n\n;; Standard interceptors.\n;; Detailed docs on each in std-interceptors.cljs\n(def debug       std-interceptors/debug)\n(def path        std-interceptors/path)\n(def enrich      std-interceptors/enrich)\n(def trim-v      std-interceptors/trim-v)\n(def after       std-interceptors/after)\n(def on-changes  std-interceptors/on-changes)\n\n\n;; Utility functions for creating your own interceptors\n;;\n;;  (def my-interceptor\n;;     (->interceptor                ;; used to create an interceptor\n;;       :id     :my-interceptor     ;; an id - decorative only\n;;       :before (fn [context]                         ;; you normally want to change :coeffects\n;;                  ... use get-coeffect  and assoc-coeffect\n;;                       )\n;;       :after  (fn [context]                         ;; you normally want to change :effects\n;;                 (let [db (get-effect context :db)]  ;; (get-in context [:effects :db])\n;;                   (assoc-effect context :http-ajax {...}])))))\n;;\n(def ->interceptor   interceptor/->interceptor)\n(def get-coeffect    interceptor/get-coeffect)\n(def assoc-coeffect  interceptor/assoc-coeffect)\n(def get-effect      interceptor/get-effect)\n(def assoc-effect    interceptor/assoc-effect)\n(def enqueue         interceptor/enqueue)\n\n\n;; --  logging ----------------------------------------------------------------\n;; Internally, re-frame uses the logging functions: warn, log, error, group and groupEnd\n;; By default, these functions map directly to the js/console implementations,\n;; but you can override with your own fns (set or subset).\n;; Example Usage:\n;;   (defn my-fn [& args]  (post-it-somewhere (apply str args)))  ;; here is my alternative\n;;   (re-frame.core/set-loggers!  {:warn my-fn :log my-fn})       ;; override the defaults with mine\n(def set-loggers! loggers/set-loggers!)\n\n;; If you are writing an extension to re-frame, like perhaps\n;; an effects handler, you may want to use re-frame logging.\n;;\n;; usage: (console :error \"Oh, dear God, it happened: \" a-var \" and \" another)\n;;        (console :warn \"Possible breach of containment wall at: \" dt)\n(def console loggers/console)\n\n\n;; -- unit testing ------------------------------------------------------------\n\n(defn make-restore-fn\n  \"Checkpoints the state of re-frame and returns a function which, when\n  later called, will restore re-frame to that checkpointed state.\n\n  Checkpoint includes app-db, all registered handlers and all subscriptions.\n  \"\n  []\n  (let [handlers @registrar/kind->id->handler\n        app-db   @db/app-db\n\t\t\t\tsubs-cache @subs/query->reaction]\n    (fn []\n\t\t\t;; call `dispose!` on all current subscriptions which\n\t\t\t;; didn't originally exist.\n      (let [original-subs (set (vals subs-cache))\n            current-subs  (set (vals @subs/query->reaction))]\n        (doseq [sub (set/difference current-subs original-subs)]\n          (interop/dispose! sub)))\n\n      ;; Reset the atoms\n      ;; We don't need to reset subs/query->reaction, as\n      ;; disposing of the subs removes them from the cache anyway\n      (reset! registrar/kind->id->handler handlers)\n      (reset! db/app-db app-db)\n      nil)))\n\n(defn purge-event-queue\n  \"Remove all events queued for processing\"\n  []\n  (router/purge re-frame.router/event-queue))\n\n;; -- Event Processing Callbacks  ---------------------------------------------\n\n(defn add-post-event-callback\n  \"Registers a function `f` to be called after each event is processed\n   `f` will be called with two arguments:\n    - `event`: a vector. The event just processed.\n    - `queue`: a PersistentQueue, possibly empty, of events yet to be processed.\n\n   This is useful in advanced cases like:\n     - you are implementing a complex bootstrap pipeline\n     - you want to create your own handling infrastructure, with perhaps multiple\n       handlers for the one event, etc.  Hook in here.\n     - libraries providing 'isomorphic javascript' rendering on  Nodejs or Nashorn.\n\n  'id' is typically a keyword. Supplied at \\\"add time\\\" so it can subsequently\n  be used at \\\"remove time\\\" to get rid of the right callback.\n  \"\n  ([f]\n   (add-post-event-callback f f))   ;; use f as its own identifier\n  ([id f]\n   (router/add-post-event-callback re-frame.router/event-queue id f)))\n\n\n(defn remove-post-event-callback\n  [id]\n  (router/remove-post-event-callback re-frame.router/event-queue id))\n\n\n;; --  Deprecation ------------------------------------------------------------\n;; Assisting the v0.7.x ->  v0.8.x transition.\n(defn register-handler\n  [& args]\n  (console :warn  \"re-frame:  \\\"register-handler\\\" has been renamed \\\"reg-event-db\\\" (look for registration of\" (str (first args)) \")\")\n  (apply reg-event-db args))\n\n(defn register-sub\n  [& args]\n  (console :warn  \"re-frame:  \\\"register-sub\\\" is deprecated. Use \\\"reg-sub-raw\\\" (look for registration of\" (str (first args)) \")\")\n  (apply reg-sub-raw args))\n"]}