{"version":3,"file":"rewrite_clj.zip.insert.js","sources":["rewrite_clj/zip/insert.cljs"],"mappings":";;;;;;+BAOE,+GAAA,yCAAA,vJAACA,wDAAAA,6DAAAA,rJADH,AAAegB;AAGf;;;;wEAGGQ,QAAQC,UAAUF,OAAOrB,KAAKC,tEAHjC,hCAAOO;AAIL,IAAME,YAAU,CAACC,wDAAAA,8DAAAA,RAAYV,0CAAAA,zKAJ/B;IAKQI,YAAU,CAACiB,wCAAAA,8CAAAA,RAAQtB,0BAAAA;qEAClB,kBAAI,iBAAAG,mBAAI,AAACC,cAAIC,zIAFpB,AAKO,OAACqB,+CAAOH,UAAUvB;AAHd,AAAA,GAAAG;AAAAA;;AAAoB,OAACG,6CAAeD;;kKAEtC,+CAAA,/CAACe,kIAAQN,6BAAMJ,kBAAWW,7UAD1B,+CAAA,/CAACD,kIAAQV,kBAAWW;;AAI/B;;;sCAAA,tCAAMtB,oFAEHC,KAAKC;AAFR,wMAOID,KAAKC,xKAHLC,kBACAgB,vDAFF,gFAAA,zEAACV,4JAGEM;;AAGL;;;kFAEGd,KAAKC,lDAFR,rCAAMY;AAGJ,8EAAA,vEAACL,8BACCC,iKAGAT,KAAKC,3MAPT,sDAKIkB,2GACCL;;AAGL;;;oFAEGd,KAAKC,nDAFR,tCAAMwB;AAGJ,+EAAA,xEAACjB,+CAECI,0DAEAZ,KAAKC,rHAPT,qCAIIe;;AAKJ;;;sCAAA,tCAAMQ,oFAEHxB,KAAKC;AACN,qCAAA,WAAAM,zCAACC,PAHH;AAGE,AACG,IAAAO,WAAAR;IAAAQ,eAAA,EAAA,CAAAA,YAAA,OAAA,KAAA,iBAAAA,jBAAUC;AAAV,AAAA,GAAA,CAAAD,gBAAA;AAAA;;AAAA,6BAAAA,tBAAiBE;;6DAGlBjB,KAAKC,tCAJP,zBAEE0B","names":["rewrite-clj.node/spaces","rewrite-clj.zip.insert/insert-right","zloc","item","clojure.zip/right","or__3922__auto__","cljs.core/not","next-node","rewrite-clj.zip.whitespace/whitespace?","p1__28925#","rewrite-clj.zip.insert/insert","clojure.zip/left","item-node","rewrite-clj.node/coerce","clojure.zip/insert-child","rewrite-clj.zip.insert/insert-left","rewrite-clj.zip.insert/space","G__28926","clojure.zip/down","clojure.zip/rightmost","clojure.zip/insert-right","clojure.zip/insert-left","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","prefix","move-fn","insert-fn","rewrite-clj.zip.insert/append-child","rewrite-clj.zip.insert/insert-child","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","clojure.zip/append-child"],"sourcesContent":["(ns ^:no-doc rewrite-clj.zip.insert\n  (:require [rewrite-clj.zip.base :as base]\n            [rewrite-clj.zip.whitespace :as ws]\n            [rewrite-clj.node :as node]\n            [clojure.zip :as z]))\n\n(def ^:private space\n  (node/spaces 1))\n\n(defn- insert\n  \"Generic insertion helper. If the node reached by `move-fn`\n   is a whitespace, insert an additional space.\"\n  [move-fn insert-fn prefix zloc item]\n  (let [item-node (node/coerce item)\n        next-node (move-fn zloc)]\n    (->> (if (or (not next-node) (ws/whitespace? next-node))\n           (concat [item-node] prefix)\n           (concat [space item-node] prefix))\n         (reduce insert-fn zloc))))\n\n(defn insert-right\n  \"Insert item to the right of the current location. Will insert a space if necessary.\"\n  [zloc item]\n  (insert\n    z/right\n    z/insert-right\n    [space]\n    zloc item))\n\n(defn insert-left\n  \"Insert item to the right of the left location. Will insert a space if necessary.\"\n  [zloc item]\n  (insert\n    z/left\n    z/insert-left\n    [space]\n    zloc item))\n\n(defn insert-child\n  \"Insert item as first child of the current node. Will insert a space if necessary.\"\n  [zloc item]\n  (insert\n    z/down\n    z/insert-child\n    []\n    zloc item))\n\n(defn append-child\n  \"Insert item as last child of the current node. Will insert a space if necessary.\"\n  [zloc item]\n  (insert\n    #(some-> % z/down z/rightmost)\n    z/append-child\n    []\n    zloc item))\n"]}