{"version":3,"file":"re_frame.events.js","sources":["re_frame/events.cljc"],"mappings":"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","names":["re-frame.trace/is-trace-enabled?","new-trace__38173__auto__","cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic","cljs.core.update.cljs$core$IFn$_invoke$arity$4","re-frame.trace/*current-trace*","cljs.core/merge","cljs.core/deref","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","re-frame.db/app-db","event-v","*handling*38397","re-frame.events/*handling*","make-chain","interceptors","re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic","*current-trace*38398","re-frame.trace/start-trace","end__38171__auto__","re-frame.interop/now","duration__38172__auto__","cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3","re-frame.trace/traces","cljs.core/conj","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","re-frame.trace/run-tracing-callbacks!","event-id","temp__5457__auto__","not-i","cljs.core/first","cljs.core.remove.cljs$core$IFn$_invoke$arity$2","re-frame.interceptor/interceptor?","chain","re-frame.utils/first-in-vector","temp__5455__auto__","re_frame.registrar.get_handler.cljs$core$IFn$_invoke$arity$3","re-frame.events/kind","re-frame.events/flatten-and-remove-nils","cljs.core/coll?","id","re-frame.registrar/register-handler","cljs.core/fn?","re-frame.interceptor/execute","cljs.core/empty?","re-frame.events/register","re-frame.interop/debug-enabled?","js/Error","re-frame.registrar/kinds","p1__38391#","cljs.core/flatten","cljs.core/nil?","re-frame.events/handle"],"sourcesContent":["(ns re-frame.events\n  (:require [re-frame.db          :refer [app-db]]\n            [re-frame.utils       :refer [first-in-vector]]\n            [re-frame.interop     :refer [empty-queue debug-enabled?]]\n            [re-frame.registrar   :refer [get-handler register-handler]]\n            [re-frame.loggers     :refer [console]]\n            [re-frame.interceptor :as  interceptor]\n            [re-frame.trace       :as trace :include-macros true]))\n\n\n(def kind :event)\n(assert (re-frame.registrar/kinds kind))\n\n(defn- flatten-and-remove-nils\n  \"`interceptors` might have nested collections, and contain nil elements.\n  return a flat collection, with all nils removed.\n  This function is 9/10 about giving good error messages.\"\n  [id interceptors]\n  (let [make-chain  #(->> % flatten (remove nil?))]\n    (if-not debug-enabled?\n      (make-chain interceptors)\n      (do    ;; do a whole lot of development time checks\n        (when-not (coll? interceptors)\n          (console :error \"re-frame: when registering\" id \", expected a collection of interceptors, got:\" interceptors))\n        (let [chain (make-chain interceptors)]\n          (when (empty? chain)\n            (console :error \"re-frame: when registering\" id \", given an empty interceptor chain\"))\n          (when-let [not-i (first (remove interceptor/interceptor? chain))]\n            (if (fn? not-i)\n              (console :error \"re-frame: when registering\" id \", got a function instead of an interceptor. Did you provide old style middleware by mistake? Got:\" not-i)\n              (console :error \"re-frame: when registering\" id \", expected interceptors, but got:\" not-i)))\n          chain)))))\n\n\n(defn register\n  \"Associate the given event `id` with the given collection of `interceptors`.\n\n   `interceptors` may contain nested collections and there may be nils\n   at any level,so process this structure into a simple, nil-less vector\n   before registration.\n\n   Typically, an `event handler` will be at the end of the chain (wrapped\n   in an interceptor).\"\n  [id interceptors]\n  (register-handler kind id (flatten-and-remove-nils id interceptors)))\n\n\n\n;; -- handle event --------------------------------------------------------------------------------\n\n(def ^:dynamic *handling* nil)    ;; remember what event we are currently handling\n\n(defn handle\n  \"Given an event vector `event-v`, look up the associated interceptor chain, and execute it.\"\n  [event-v]\n  (let [event-id  (first-in-vector event-v)]\n    (if-let [interceptors  (get-handler kind event-id true)]\n      (if *handling*\n        (console :error \"re-frame: while handling\" *handling* \", dispatch-sync was called for\" event-v \". You can't call dispatch-sync within an event handler.\")\n        (binding [*handling*  event-v]\n          (trace/with-trace {:operation event-id\n                             :op-type   kind\n                             :tags      {:event event-v}}\n            (trace/merge-trace! {:tags {:app-db-before @app-db}})\n            (interceptor/execute event-v interceptors)\n            (trace/merge-trace! {:tags {:app-db-after @app-db}})))))))\n\n\n"]}