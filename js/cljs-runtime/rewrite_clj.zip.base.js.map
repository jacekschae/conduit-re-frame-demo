{"version":3,"file":"rewrite_clj.zip.base.js","sources":["rewrite_clj/zip/base.cljs"],"mappings":";;;;;;AASA;;;0EAEGa,zCAFH,jCAAMe;8IAMFnB,pHAFAW,1BADF,OAACM,PAHH,wDAKI,AAACI,6CAAKC,cAAIC,6DAEVnB;;AAEJ;;;;8DAGGA,nCAHH,3BAAMI;;AAIJ,GAAI,oMAAA,pMAACI,6CAAE,CAACF,qDAAAA,2DAAAA,RAASN,uCAAAA,hMAJnB;AAKI,IAAMR,MAAI,AAACuB,+BAAKf;AACd,IAAAT,mBAAI,yEAAA,iBAAIC,jBAAIC,zEAAOC,vBADrB;AACE,AAAA,oBAAAH;AAAAA;;AACIC;;;AACN,eAAO,iBAAA8B,WAAA,mFAAkBtB;AAAlB,AAAA,8HAAAsB,kDAAAA,xKAACC,4DAAAA,sEAAAA;;;;;;;;AAIZ;;;8DAEGnC,nCAFH,3BAAMsC;AAGJ,IAAArB,WAAQjB,fAHV;IAGEiB,eAAA,EAAA,CAAAA,YAAA,OAAA,KAAA,iBAAAA,jBAAaP;AAAb,AAAA,GAAA,CAAAO,gBAAA;AAAA;;AAAA,gHAAAA,+CAAAA,vJAAoBC,qDAAAA,mEAAAA;;;AAEtB;;;6BAAA,7BAAMU,kEAEH5B;AAFH,AAGE,IAAAoC,WAAQpC;IAARoC,eAAA,EAAA,CAAAA,YAAA,OAAA,KAAA,iBAAAA,jBAAa1B;AAAb,AAAA,GAAA,CAAA0B,gBAAA;AAAA;;AAAA,oHAAAA,iDAAAA,7JAAoBC,uDAAAA,qEAAAA;;;AAEtB;;;oCAAA,pCAAMxB,gFAEHb;AAFH,AAGE,IAAAqB,WAAQrB;IAARqB,eAAA,EAAA,CAAAA,YAAA,OAAA,KAAA,iBAAAA,jBAAaX;AAAb,AAAA,GAAA,CAAAW,gBAAA;AAAA;;AAAA,kIAAAA,wDAAAA,lLAAoBC,8DAAAA,4EAAAA;;;AAEtB;;;oEAEGtB,tCAFH,9BAAMgC;AAGJ,IAAA7B,mBAAI,iBAAAM,WAAQT,nDAHd;IAGMS,eAAA,EAAA,CAAAA,YAAA,OAAA,KAAA,iBAAAA,jBAAaC;AAAb,AAAA,GAAA,CAAAD,gBAAA;AAAA;;AAAA,sHAAAA,kDAAAA,hKAAoBE,wDAAAA,sEAAAA;;;AAAxB,AAAA,oBAAAR;AAAAA;;AAAA;;;AAKF;;;0EAEGI,zCAFH,jCAAM0B;AAGJ,IAAAnB,WAAQP,fAHV;IAGEO,eAAA,EAAA,CAAAA,YAAA,OAAA,KAAA,oCAAAA,pCAAUC;AAAV,AAAA,GAAA,CAAAD,gBAAA;AAAA;;AAAA,gCAAAA,zBAA6BE;;;AAK/B;;;8BAAA,9BAAMO,oEAEHvB;AAFH,AAGE,IAAAwB,WAAQxB;IAARwB,eAAA,EAAA,CAAAA,YAAA,OAAA,KAAA,iBAAAA,jBAAad;AAAb,AAAA,GAAA,CAAAc,gBAAA;AAAA;;AAAA,sHAAAA,kDAAAA,hKAAoBtB,wDAAAA,sEAAAA;;;AAEtB;;;mCAAA,nCAAMwB,8EAEH1B;AACD,IAAAD,WAAQC,fAHV;IAGED,eAAA,EAAA,CAAAA,YAAA,OAAA,KAAA,iBAAAA,jBAAaE;AAAb,AAAA,GAAA,CAAAF,gBAAA;AAAA;;AAAA,sHAAAA,kDAAAA,hKAAoBG,wDAAAA,sEAAAA","names":["G__28905","zloc","clojure.zip/root","rewrite-clj.node/string","or__3922__auto__","top","clojure.zip/down","rewrite_clj.zip.whitespace.skip_whitespace.cljs$core$IFn$_invoke$arity$1","s","rewrite-clj.node/replace-children","G__28901","clojure.zip/node","rewrite-clj.node/length","node","rewrite-clj.zip.base/child-sexprs","G__28902","rewrite-clj.parser/parse-string-all","rewrite-clj.zip.base/edn","G__28894","rewrite-clj.node/tag","rewrite-clj.node/inner?","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","G__28899","rewrite-clj.node/child-sexprs","rewrite-clj.zip.base/string","G__28904","clojure.zip/zipper","rewrite-clj.zip.base/root-string","rewrite-clj.zip.base/edn*","rewrite-clj.zip.base/sexpr","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","cljs.core/seq","rewrite-clj.node/children","rewrite-clj.zip.base/length","rewrite-clj.zip.base/of-string","G__28891","rewrite-clj.node/forms-node","G__28896","rewrite-clj.node/sexpr","rewrite-clj.zip.base/tag"],"sourcesContent":["(ns rewrite-clj.zip.base\n  (:refer-clojure :exclude [print])\n  (:require [rewrite-clj.node :as node]\n            [rewrite-clj.parser :as p]\n            [rewrite-clj.zip.whitespace :as ws]\n            [clojure.zip :as z]))\n\n;; ## Zipper\n\n(defn edn*\n  \"Create zipper over the given Clojure/EDN node.\"\n  [node]\n  (z/zipper\n    node/inner?\n    (comp seq node/children)\n    node/replace-children\n    node))\n\n(defn edn\n  \"Create zipper over the given Clojure/EDN node and move\n   to the first non-whitespace/non-comment child.\"\n  [node]\n  (if (= (node/tag node) :forms)\n    (let [top (edn* node)]\n      (or (-> top z/down ws/skip-whitespace)\n          top))\n    (recur (node/forms-node [node]))))\n\n;; ## Inspection\n\n(defn tag\n  \"Get tag of node at the current zipper location.\"\n  [zloc]\n  (some-> zloc z/node node/tag))\n\n(defn sexpr\n  \"Get sexpr represented by the given node.\"\n  [zloc]\n  (some-> zloc z/node node/sexpr))\n\n(defn child-sexprs\n  \"Get children as s-expressions.\"\n  [zloc]\n  (some-> zloc z/node node/child-sexprs))\n\n(defn length\n  \"Get length of printable string for the given zipper location.\"\n  [zloc]\n  (or (some-> zloc z/node node/length) 0))\n\n\n;; ## Read\n\n(defn of-string\n  \"Create zipper from String.\"\n  [s]\n  (some-> s p/parse-string-all edn))\n\n\n;; ## Write\n\n(defn string\n  \"Create string representing the current zipper location.\"\n  [zloc]\n  (some-> zloc z/node node/string))\n\n(defn root-string\n  \"Create string representing the zipped-up zipper.\"\n  [zloc]\n  (some-> zloc z/root node/string))\n\n;; (defn- print!\n;;   [s writer]\n;;   (if writer\n;;     (.write ^java.io.Writer writer s)\n;;     (recur s *out*)))\n\n;; (defn print\n;;   \"Print current zipper location.\"\n;;   [zloc & [writer]]\n;;   (some-> zloc\n;;           string\n;;           (print! writer)))\n\n;; (defn print-root\n;;   \"Zip up and print root node.\"\n;;   [zloc & [writer]]\n;;   (some-> zloc\n;;           root-string\n;;           (print! writer)))\n"]}